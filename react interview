Hi Aayushi, good afternoon. I’m Teekam from GR Silver International.
I’ll be conducting your interview today.
First of all, please tell me about yourself.


Are you currently working, or have you left your job?

What was the reason for leaving the company?

How much total experience do you have?

How much experience do you have with Flutter?

What types of projects have you worked on?

Can you explain your last project?

What was your role in that project?

Which technologies and tools have you used?

Have you worked with APIs and third-party integrations?

Do you have experience with version control systems like Git?

What challenges did you face in your projects, and how did you solve them?

Have you worked in a team or individually?

Are you comfortable with deadlines and pressure?

What are your strengths and weaknesses?

Why should we hire you?
 



### **1. What is the Virtual DOM, and how does React use it?**

**Answer:**
The Virtual DOM is a lightweight copy of the actual DOM. React keeps a virtual representation of the UI in memory. When the state changes, React updates the virtual DOM first, compares it with the previous version using a **diffing algorithm**, and then updates only the parts of the real DOM that changed. This improves performance by minimizing direct DOM manipulation.

---

### **2. Explain React Fiber.**

**Answer:**
React Fiber is the reimplementation of React’s core algorithm for rendering. It allows React to **split rendering work into chunks** and prioritize updates based on their importance (e.g., animations vs background tasks). This improves performance for complex applications.

---

### **3. Difference between controlled and uncontrolled components.**

**Answer:**

* **Controlled component:** The form element’s value is controlled by React state. Example: `<input value={stateValue} onChange={handleChange} />`.
* **Uncontrolled component:** The form element maintains its own state, and React uses refs to access values. Example: `<input ref={inputRef} />`.

---

### **4. What are hooks in React?**

**Answer:**
Hooks are functions that let you “hook into” React state and lifecycle features in **functional components**. Common hooks:

* `useState` – manage state
* `useEffect` – side effects
* `useContext` – access context
* `useReducer` – complex state logic
* `useRef` – persist values without rerender

---

### **5. Difference between `useEffect` and `useLayoutEffect`.**

**Answer:**

* `useEffect` runs **after the render is painted to the screen** (asynchronous).
* `useLayoutEffect` runs **synchronously after DOM mutations but before the paint**, useful for measurements and DOM manipulations.

---

### **6. What is reconciliation in React?**

**Answer:**
Reconciliation is the process of **updating the DOM efficiently**. React compares the previous Virtual DOM with the new one (diffing) and only applies the minimal set of changes needed.

---

### **7. Explain the concept of keys in React.**

**Answer:**
Keys help React identify which items in a list **have changed, added, or removed**. They must be unique among siblings. Using index as a key is discouraged if list order can change because it may cause rendering bugs.

---

### **8. What is Context API?**

**Answer:**
The Context API allows passing data through the component tree **without prop drilling**. Useful for global state like theme, authentication, or language settings.

```js
const ThemeContext = React.createContext('light');
<ThemeContext.Provider value="dark">
  <App />
</ThemeContext.Provider>
```

---

### **9. Difference between `React.memo` and `useMemo`.**

**Answer:**

* `React.memo` – HOC to **memoize functional components** to prevent unnecessary rerenders.
* `useMemo` – Hook to **memoize expensive calculations** inside a component.

---

### **10. How to optimize React performance?**

**Answer:**

* Use `React.memo` for pure components
* Use `useMemo` and `useCallback`
* Lazy load components with `React.lazy`
* Code splitting
* Avoid anonymous functions in JSX
* Properly manage state to avoid unnecessary rerenders

---

### **11. Explain Error Boundaries.**

**Answer:**
Error Boundaries are React components that **catch JavaScript errors anywhere in their child component tree** and display a fallback UI instead of crashing the whole app.

```js
class ErrorBoundary extends React.Component {
  state = { hasError: false };
  static getDerivedStateFromError() { return { hasError: true }; }
  render() { return this.state.hasError ? <h1>Error!</h1> : this.props.children; }
}
```

---

### **12. Difference between `useReducer` and `useState`.**

**Answer:**

* `useState` – simpler, for basic state
* `useReducer` – better for **complex state logic** with multiple sub-values or actions, similar to Redux.

---

### **13. How does React handle forms?**

**Answer:**

* Controlled components: React state is the source of truth
* Uncontrolled components: use refs to access values
* Validation can be done using controlled inputs, libraries like Formik, or React Hook Form.

---

### **14. What are higher-order components (HOCs)?**

**Answer:**
HOCs are **functions that take a component and return a new component**. Used for reusing logic (e.g., authentication, theming).

```js
function withAuth(Component) {
  return function Wrapped(props) {
    return isLoggedIn ? <Component {...props} /> : <Login />;
  };
}
```

---

### **15. Difference between class and functional components.**

**Answer:**

* Class components: support state and lifecycle methods using `this.state` and `this.setState`
* Functional components: simpler, can use hooks for state and lifecycle features, preferred in modern React

---

### **16. Explain React Suspense and Lazy loading.**

**Answer:**

* `React.lazy` allows **dynamic import of components**, reducing bundle size.
* `Suspense` allows you to show a fallback UI while the lazy component is loading.

```js
const LazyComponent = React.lazy(() => import('./Component'));
<Suspense fallback={<Loading />}>
  <LazyComponent />
</Suspense>
```

---

### **17. What is Prop Drilling and how to avoid it?**

**Answer:**
Prop Drilling is passing props through multiple layers of components unnecessarily.
**Solutions:** Context API, Redux, Zustand, or other state management tools.

---

### **18. How does reconciliation handle lists with keys?**

**Answer:**

* React uses keys to **match elements between renders**.
* If keys are stable, React reuses components; if keys change, React destroys and recreates them.
* Helps prevent unnecessary rerenders and DOM mutations.

---

### **19. Difference between React Router v5 and v6.**

**Answer:**

* v6 uses `<Routes>` instead of `<Switch>`
* Nested routes are simplified
* `useNavigate()` replaces `useHistory()`
* Route matching is **always exact by default**

---

### **20. Explain state management options in React.**

**Answer:**

* **Local state:** `useState`, `useReducer`
* **Context API:** lightweight global state
* **Redux:** robust global state with middleware
* **Zustand / Recoil / Jotai:** simpler state management alternatives
* **Server state:** `React Query`, `SWR`

---

✅ These 20 questions cover **core concepts, hooks, optimization, and state management** that are expected for 3+ years of React experience.

---

If you want, I can also create a **“React Advanced Scenario Questions” set with code examples** – which is very common for 3+ years interviews. It would include **performance issues, state optimization, and large-scale architecture**.

Do you want me to create that too?
